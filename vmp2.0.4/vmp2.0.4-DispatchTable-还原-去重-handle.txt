00405A00      74D34300      dd NOTEPAD.0043D374  //VMP_POP_REG8
00405A04      3BD44300      dd NOTEPAD.0043D43B  //VMP_PUSH32_MEMORY32 (把EBPSTACK栈顶数据作为内存地址，从中读取1个dword的数据替换EBPSTACK栈顶的内存地址)
00405A08      89D04300      dd NOTEPAD.0043D089  //VMP_JMP (把EBPSTACK栈顶地址移动到ESI，重新初始化EBX和ESI。)
00405A0C      51DE4300      dd NOTEPAD.0043DE51  //VMP_SHRD32_EBPSTACK (EBPSTACK双精度右移指令，执行完毕后，结果和EFLAGS存储到EBPSTACK)
00405A10      BEEA4300      dd NOTEPAD.0043EABE  //VMP_COPY32_EBPSTACK (把EBPSTACK栈顶数据作为堆栈地址，从中读取一个dword的数据替换EBPSTACK栈顶数据)
00405A14      70D74300      dd NOTEPAD.0043D770
00405A18      E0EA4300      dd NOTEPAD.0043EAE0
00405A1C      3FE84300      dd NOTEPAD.0043E83F  //VMP_PUSH_IMM32
00405A20      77EF4300      dd NOTEPAD.0043EF77  //VMP_CALL (VM中最复杂的伪指令，用于系统API调用和程序过程调用。ESI数据中取得参数的个数，EAX循环取得参数，压入ESP指针指向的常规堆栈。大量使用[ESP+X]的方式调用，掺杂着废压栈操作，静态看代码难以看出。返回地址是常量压入的0043EEB7。这条伪指令涉及内容众多，分支庞大，系统API调用和程序过程调用的走向都是不同的，在后面章节详述。我这里列举的是一次只有1个参数的系统API调用)
00405A24      2ED74300      dd NOTEPAD.0043D72E  //VMP_PUSH32_EBP (复制EBP指针到EBPSTACK栈顶)
00405A28      E6E74300      dd NOTEPAD.0043E7E6  //VMP_POP_REG16
00405A2C      D2D74300      dd NOTEPAD.0043D7D2  //VMP_SHR32_EBPSTACK (把EBPSTACK栈顶1个dword作为操作数，[EBP+4]作为移动位数，逻辑右移。结果dword存储在第二个操作数和第一个操作数的高byte,EFLAGS标志存储在栈顶)
00405A30      91D84300      dd NOTEPAD.0043D891  //VMP_MOV_MEMORY32_EBPSTACK32 (EBPSTACK栈顶数据作为地址，把栈顶的第二个dword存储到地址内)
00405A34      56DC4300      dd NOTEPAD.0043DC56  //VMP_PUSH16_REG16 (从EDISTACK中读取1个word数据压入EBPSTACK)
00405A38      EDE94300      dd NOTEPAD.0043E9ED  //VMP_MOV_MEMORY16_EBPSTACK16 (EBPSTACK栈顶数据作为地址，把栈顶的第二个word存储到地址内)
00405A3C      A5D34300      dd NOTEPAD.0043D3A5  //VMP_PUSH32_IMM8
00405A40      89CE4300      dd NOTEPAD.0043CE89  //VMP_HASH (计算一段数据的HASH值，EBPSTACK栈顶第一个dword是数据地址，第二个dword是数据大小)
00405A44      13DE4300      dd NOTEPAD.0043DE13  //VMP_MOVE_EBP_EBPSTACK (给EBP寄存器赋值EBPSTACK栈顶数据)
00405A48      99E14300      dd NOTEPAD.0043E199
00405A4C      24D54300      dd NOTEPAD.0043D524  //VMP_SHLD32_EBPSTACK (EBPSTACK双精度左移指令，执行完毕后，结果和EFLAGS存储到EBPSTACK)
00405A50      54DD4300      dd NOTEPAD.0043DD54  //VMP_GET_FS:[EBPSTACK] (读取FS[X]数据，X=EBPSTACK栈顶数据)
00405A54      98D14300      dd NOTEPAD.0043D198  //VMP_NAND32 (dword版的与非门，从EBPSTACK的栈顶读取2个dword作为操作数，结果存储在第二个操作数位置，EFLAGS标志存储在栈顶。)
00405A58      00DB4300      dd NOTEPAD.0043DB00
00405A5C      2ED84300      dd NOTEPAD.0043D82E
00405A60      81CF4300      dd NOTEPAD.0043CF81  //VMP_PUSH16_REG8 (从EDISTACK中读取1个byte数据,按照word方式压入EBPSTACK)
00405A64      BDD84300      dd NOTEPAD.0043D8BD  //VMP_PUSH16_MEMORY8 (把EBPSTACK栈顶数据作为内存地址，从中读取1个byte的数据，按照word的方式压入EBPSTACK)
00405A68      1FED4300      dd NOTEPAD.0043ED1F
00405A6C      F6EC4300      dd NOTEPAD.0043ECF6
00405A70      70E74300      dd NOTEPAD.0043E770
00405A74      53D24300      dd NOTEPAD.0043D253
00405A78      C9CD4300      dd NOTEPAD.0043CDC9
00405A7C      1CD24300      dd NOTEPAD.0043D21C  //VMP_PUSH16_IMM16
00405A80      CCD64300      dd NOTEPAD.0043D6CC  //VMP_MOV_MEMORY8_EBPSTACK8 (EBPSTACK栈顶数据作为地址，把栈顶的第二个word存储到地址内)
00405A84      C8D84300      dd NOTEPAD.0043D8C8  //VMP_SET_FS:[EBPSTACK] (给FS[X]传递Y数据，X=EBPSTACK栈顶数据，Y=EBPSTACK栈顶第2个数据。在实践中都是用于给FS[0]赋值，构建SEH)
00405A88      CAE94300      dd NOTEPAD.0043E9CA  //VMP_PUSH16_MEMORY16 (把EBPSTACK栈顶数据作为内存地址，从中读取1个byte的数据压入EBPSTACK)
00405A8C      57D14300      dd NOTEPAD.0043D157  //VMP_MOV_MEMORY32_EBPSTACK32 (EBPSTACK栈顶数据作为地址，把栈顶的第二个dword存储到地址内)
00405A90      78D94300      dd NOTEPAD.0043D978  //VMP_PUSH16_IMM8
00405A94      F5D24300      dd NOTEPAD.0043D2F5
00405A98      11EB4300      dd NOTEPAD.0043EB11  //VMP_ADD8_EBPSTACK (把EBPSTACK栈顶的2个word数据中的低byte相加，结果存储在第二个操作数位置，EFLAGS标志存储在栈顶。)
00405A9C      A5E94300      dd NOTEPAD.0043E9A5  //VMP_SHL32_EBPSTACK (把EBPSTACK栈顶1个dword作为操作数，[EBP+4]作为移动位数，逻辑左移。结果dword存储在第二个操作数和第一个操作数的高byte,EFLAGS标志存储在栈顶。)
00405AA0      92EB4300      dd NOTEPAD.0043EB92  //VMP_NAND16 (word版的与非门，从EBPSTACK的栈顶读取2个word作为操作数，结果存储在第二个操作数位置，EFLAGS标志存储在栈顶)
00405AA4      E7D64300      dd NOTEPAD.0043D6E7
00405AA8      ACDB4300      dd NOTEPAD.0043DBAC
00405AAC      90E74300      dd NOTEPAD.0043E790  //VMP_COPY16_EBPSTACK (把EBPSTACK栈顶数据作为堆栈地址，从中读取一个byte的数据，按照word的方式压入EBPSTACK)
00405AB0      BEDF4300      dd NOTEPAD.0043DFBE  //VMP_PUSH32_REG32 (把1个dword的数据从EDISTACK压入EBPSTACK)
00405AB4      EEEF4300      dd NOTEPAD.0043EFEE  //VMP_MOV_MEMORY32_EBPSTACK32 (EBPSTACK栈顶数据作为地址，把栈顶的第二个dword存储到地址内)
00405AB8      6BE04300      dd NOTEPAD.0043E06B
00405ABC      CDE84300      dd NOTEPAD.0043E8CD
00405AC0      7DEC4300      dd NOTEPAD.0043EC7D  //VMP_POPFD_EBPSTACK (给EFLAGE寄存器赋值EBPSTACK栈顶数据)
00405AC4      69DA4300      dd NOTEPAD.0043DA69  //VMP_EXIT (给各个寄存器赋值EBPSTACK中的数据，EBPSTACK中的最后一个数据是跳转地址)
00405AC8      11DB4300      dd NOTEPAD.0043DB11  //VMP_PUSH32_IMM16
00405ACC      3CE14300      dd NOTEPAD.0043E13C
00405AD0      0ADC4300      dd NOTEPAD.0043DC0A  //VMP_POP_REG32
00405AD4      24CF4300      dd NOTEPAD.0043CF24  //VMP_ADD32_EBPSTACK (把EBPSTACK栈顶的2个dword数据相加，结果存储在[EBP+4]，EFLAGS标志存储在栈顶)